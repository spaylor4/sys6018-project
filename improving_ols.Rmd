---
title: "Improving Least Squares"
author: "Rachel Filderman, Latifa Hasan, Emily Murphy, Shannon Paylor"
date: "12/8/2020"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: cosmo
---

# Introduction

Have you recently mastered the introductory concepts in producing statistical models? Congratulations! With this knowledge, it’s now time to consider fine tuning model parameters further in order to improve the ordinary least squares (OLS) approach. One way we can do this is by determining if all of the parameters or variables are important in our model or if we instead can produce a better model after reducing the variables in the model through feature selection. You were likely introduced to subset selection in an introductory statistical model course, but there are other methods, as well, to improving OLS with feature selection. We will cover the following techniques in this tutorial with respect to the each method’s motivation and algorithm:

1. Subset Selection
    + Best Subsets
    + Stepwise Selection/Elimination
2. Penalized Regression
    + Ridge
    + Lasso
    + Elastic Net
3. Dimension Reduction
    + Principal Component Analysis (PCA)
    + Partial Least Squares (PLS)

In addition, we will demonstrate these techniques through a coding example with the following dataset.

Before we dive into dimension reduction, we will refresh a few key concepts.

### Review:
**Supervised vs Unsupervised Learning**

**Response Variable:** the variable of interest in a prediction problem, usually denoted $Y$.

**Features/predictor Variables:** data used in modeling, usually denoted $X$. In a supervised learning problem, these features are used to predict the response variable.

**Standardizing Variables:** re-scaling variables to have mean zero and variance one. Standardizing can be especially important when variables are on widely differing scales (e.g. one feature on a percentage scale with values between zero and one and another feature measured in dollars on a scale from zero to several thousand).

**Bias & Variance**

**Model Selection Criteria:** Model selection criteria are used to evaluate and compare subset regression models. Common criteria used include: 

* Adjusted R^2 = [will write equation in latex/Rmd]
Akaike Information Criterion (AIC) = [will write equation in latex/Rmd]  
* Bayesian Information Criterion (BIC) = [will write equation in latex/Rmd]  
* Residual Sum of Squares (RSS) = [will write equation in latex/Rmd]  
	
### Why improve on least squares?
OLS is not well-suited to high dimensional data. When the number of predictors $p$ is greater than the number of observations $n$, it will be possible to create a model explaining 100% of the variance in the data, which will lead to overfitting and poor prediction for new data.

### Real Life Applications:
+ DNA Sequencing
+ GDP 
+ Housing prices


# Subset Selection

# Penalized Regression

# Dimension Reduction

In the methods described so far, we have focused on feature selection and eliminating features that we decide are not significant enough for our model. However, in entirely dropping these features - however insignificant they may be - we completely miss out on any benefits these dropped variables may contribute. Instead, we could incorporate all variables strategically in order to extract as much information as possible using dimension reduction. Dimension reduction entails creating an $M$-dimensional subspace where $M$ combinations are constructed as a combination of $p$ predictors. The $M$ combinations of predictors are then used to fit a least squares linear regression model. In order to benefit from this approach, $M < p$ must hold. If $M = p$, then the resulting model amounts to using a least squares fit using all of the original predictors. We especially benefit from this approach when $p$ (number of predictors) is large relative to n (number of observations), as using $M < p$ can reduce the variance of the model. 

Dimension reduction methods generally follow two steps:  
1. Obtain the transformed predictors $Z_1$, $Z_2$,...$Z_M$  
2. Fit the model using these predictors

In the following sections, we will discuss two popular methods for dimension reduction: Principal Component Analysis (PCA) and Partial Least Squares (PLS).


## Principal Components Analysis (PCA)

Principal Components Analysis is a dimension reduction technique in which variables named principal components are constructed as linear combinations of our original variables. There are as many principal components created as there are original variables in our data. However, in order to attain a model with reduced dimensions, we will aim to drop a number of these principal components. To determine which principal components can be excluded from our model, we will  rank the principal components by their importance in predicting the response variable. Then, only the most important principal components are used in the linear model. 

We will likely want to use this method when we seek to reduce the number of variables, but do not know which ones. However, we will see that one drawback of this method is its interpretability, as we are no longer using our original predictors to predict the response but are instead using transformed predictors that each include all of our original predictors. 

Before we dive into the algorithm and steps behind PCA, it will be helpful to review how and why we use variance to rank principal components by importance.

### Constructing Principal Components

Principal components represent the directions of the data that explain a maximal amount of variance. In understanding this method, it’s important to recognize that variance explained is equivalent to information captured in a model. The more variance in the data that we can explain through a feature, the better.

The image below will help explain how this concept ties into principal component analysis. 

![](https://builtin.com/sites/default/files/inline-images/Principal%20Component%20Analysis%20second%20principal.gif)

The goal of principal component analysis is to compress as much information or variance in the first components, and thus the first principal component accounts for the largest variance in the dataset. 

In the scatterplot above, we aim to construct a principal component or line that maximizes this variance, which is when the red dots are spread out the most along the line. This line then represents more variance and the larger the variance represented by a line, the larger the dispersion of points along a line, and thus the more information the line holds.

Now that we understand how these principal components contribute to our model, let’s walk through the steps taken to construct the principal components. 

### Algorithm Behind the Method:

1. Center and standardize our original predictor variable matrix, $X$.  
    + This method is sensitive to variance in the predictor variables, so this step is necessary to ensure each variable contributes equally to the model  
2. Compute the covariance matrix by multiplying the transpose of this standardized matrix by itself.  
    + Thus, where X has been standardized: $X^TX$  
3. Compute the eigenvectors and eigenvalues of the covariance matrix, $X^TX$.  
    + Let’s pause here for a refresher on linear algebra:  
        + Eigenvectors represent directions and eigenvalues represent magnitude (or in this scenario, importance). Eigenvectors are stored in a dense matrix while eigenvalues are stored in a matrix with eigenvalues on the diagonal and zeros everywhere else. These eigenvalues on the diagonal are associated with the corresponding column in the eigenvector matrix. For example, an eigenvalue stored on the diagonal in the second column of its matrix corresponds to the second column in the eigenvector matrix.  
        + Luckily, there are functions in R that will compute these values for us, but it’s important to understand the eigenvectors and eigenvalues it outputs.  

4. Sort the eigenvalues from largest to smallest  
    + Since eigenvalues correspond to their eigenvectors, the eigenvectors are similarly sorted according to the order of their corresponding eigenvalue (put another way, the columns of the eigenvector matrix are reordered according to the reordering of the eigenvalue matrix).  
5. Multiply this sorted eigenvector matrix by the standardized version of X from step 1.  
    + As a result, we now have a standardized version of X with weights determined by the eigenvectors.  
6. With this new matrix, determine how many features (principal components) to keep in the new feature matrix. This can be done a couple of ways:  
    a) Arbitrarily determine how many dimensions to keep:  
        + This is not recommended, but at times may be appropriate for your specific analysis or problem  

    b) Set a threshold for proportion of variance explained:  
        + As explained earlier, the importance of a principal component or eigenvector is tied to variance. Further, each eigenvalue is approximately the importance of its corresponding eigenvalue (as we saw when sorting our eigenvalues and then eigenvectors). Therefore, we can create a metric for measuring the importance or variance explained by each principal component or eigenvector called the proportion of variance, which is the sum of all eigenvalues kept divided by the sum of all eigenvalues.  
        + With this metric, we can then pick a threshold of proportion of variance explained and include principal components up until we reach the set threshold.
 
     c) Use a scree plot:  
        + Similar to the method above, we can use the proportion of variance to determine how many principal components to keep.     
        + We calculate the proportion of variance for each principal component, sort the principal components by proportion of variance explained (though they technically should already be sorted in order of importance), then plot the proportion of variance explained by each principal component.  
        + We should then have a line plot with an elbow that denotes the point at which there is the largest drop in proportion of variance explained. We then decide to use the principal components up until this drop. In the scree plot below, there is a considerable drop between proportion of variance explained in PC1 to PC2. We would therefore identify PC2 as the elbow and only include the first feature (PC1) and drop the rest. As you can see, a disadvantage of this method is that it is relatively subjective.

![https://datavizpyr.com/how-to-make-scree-plot-in-r-with-ggplot2/](https://i2.wp.com/datavizpyr.com/wp-content/uploads/2020/08/Scree_plot_with_geom_line_ggplot2.png?w=600&ssl=1)

7. Use this new feature matrix with the principal components/eigenvectors we chose to keep as the new X in our linear regression model against the untransformed Y -- this type of regression using PCA is known as Principal Components Regression (PCR).  

    + Note: Each of these new variables resulting from PCA are all independent of each other, which is an important assumption that must hold for a linear model.
    
### Coding examples: 

```{r, include=FALSE}
library(dplyr)
set.seed(123)
```
There are a couple of libraries you can use for PCR - one 'pls' which also can be used for PLS (covered next). We'll first show how to run PCR using this library:
```{r, message=FALSE}
library(pls)
```
Run PCR with cross-validation:
```{r}
news = read.csv('OnlineNewsPopularity.csv') %>% select(-url, -timedelta)
pcr.fit = pcr(shares~., data = news, scale=TRUE, validation ="CV")
```
In the above code, scale is set to "TRUE" in order to standardize each predictor. Validation is set to "CV" in order to compute ten-fold cross-validation error for each possible value of M (the number of principal components used). Having the cross-validation error will give us another metric to judge principal components by.

Summary:
```{r}
summary(pcr.fit)
```
From this summary, we see that the smallest RMSE at 55 components (M=55) of 11522, at which point 100% of variance is explained.


Next, we can use the function prcomp() within the factoextra library for PCR. The difference in setting up pcr() vs. prcomp() is that prcomp() needs the data passed in with no response variable. Therefore, we create an X from our data, removing our response variable, shares.
```{r, message=FALSE}
library(factoextra)

X = news %>% select(-shares)

prcomp.fit = prcomp(X, scale = TRUE)

summary(prcomp.fit)
```
Similar to pcr(), we have a summary table with all PCs. Instead, here we have Proportion of Variance and Cumulative Proportion available to us. 

Next, visualize eigenvalues (scree plot). Show the percentage of variances explained by each principal component. 58 is passed in for "ncp" in order to visualize all PCs. If you would like to view less, you can change this input.
```{r}
fviz_eig(prcomp.fit, ncp = 58)
```


## Partial Least Squares (PLS)

Partial least squares (PLS) is very similar to principal components regression (PCR), in that both generate a new set of features that are linear combinations of the original features. However, unlike PCR, PLS incorporates information from the response variable when creating these new features. In doing so, PLS attempts to identify directions that explain the most variance in both the features and the response, rather than just explaining the variance in the features. Because PCR only considers the variance in the features, it may not be best for prediction, particularly if there is some variance in the features unrelated to the variance in the response.

PLS can be thought of as a supervised alternative to PCR's unsupervised approach. This is not to say that PCR cannot be used for supervised learning problems (it can be used for either supervised or unsupervised problems), but instead describes the method of generating the new features. PLS, on the other hand, can only be used for supervised problems, since the response variable is used in the creation of the new features.

<iframe src="https://giphy.com/embed/ehVD71SQYsCHWrWgvs" width="480" height="271" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/moodman-ehVD71SQYsCHWrWgvs">via GIPHY</a></p>

### Algorithm

PLS generates new features $Z$ that are linear combinations of the original features $X$. This means that the $m$th new feature can be written as $Z_m = \sum_{j = 1}^p \phi_{jm}X_j$, where $p$ is the total number of original features.

This process for creating these new features is as follows:

1. Standardize all features.

2. Initialize $X^{(0)} = X$ and $m=1$.

3. Compute the first direction $Z_1$ by setting $\phi_{j1}$ equal to the coefficient of ordinary least squares linear regression between $Y$ and $X_j$. In doing so, the $X_j$'s most highly correlated with $Y$ receive the highest weights in $Z_1$.

4. Orthogonalize $X$ with respect to $Z_1$ by regressing each variable $X_j$ on $Z_1$ and taking the residuals. Denote these orthogonalized values $X^{(1)}$. This means that $X^{(1)}$ is essentially the information not already explained by the first direction.

5. Repeat steps 2-4 to calculate each $Z_m$ for $m = 2, ..., p$, using the orthogonalized $X^{(m-1)}$ output from the previous step instead of $X$ to generate $Z_m$. So $X^{(1)}$ is used to calculate $Z_2$, $X^{(2)}$ is used to calculate $Z_3$, and so on.

6. Use ordinary least squares to regress $Y$ on $Z_1, ..., Z_m$ for some $m \le p$. Generally use cross-validation to choose the best value of $m$.

### Code

```{r read_data, message=FALSE}
library(tidyverse)
news <- read_csv("OnlineNewsPopularity.csv")

news_cl <- select(news, -url, -timedelta)
```

To implement PLS in R, we can use the `pls` package. After loading the package, the basic syntax for fitting PLS regression is very similar to that of linear regression with the `lm` function, though in this case we will use the `plsr` function. The first argument is a formula to tell the function what the response and predictor variables are. In this case, we're using online news data with `shares` as the response and all other variables as predictors. To avoid having to type out 58 variables in the formula, we can instead use `shares ~ .` to indicate that all columns besides `shares` should be treated as predictor variables. Additionally, to standardize the predictors, we can specify `scale = TRUE` and `center = TRUE`.

```{r fit_pls, message=FALSE}
#load the pls library
library(pls)

#fit the pls regression
pls_fit <- plsr(shares ~ ., data = news_cl, scale = TRUE, center = TRUE)

summary(pls_fit)
```

The summary of the fit shows the percentage of variance explained by each additional component. In this example, we see that five components explain 24% of the variance in the data, and 10 components explain 38% of the variance in the data. 

We can also make predictions for new data using our PLS model. As with fitting the model, this process is very similar to ordinary least squares regression. We will use the `predict` function, but will need to include an additional parameter `ncomp` to specify the number of components to include.

More info on the `pls` package is available [here](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf).

```{r pred_pls}
#predict for given number of components (3 in this case)
predict(pls_fit, ncomp = 3, newdata = news_cl[39640:39644,])
```

While the percentage of variance explained gives us some information about how many components to include, best practice is to choose this number using cross-validation. One method of cross-validation would involve a double for loop to iterate through subsets of the data and number of components, making predictions and calculating an error measure (generally root mean squared error for numeric predictor variables) for each combination, then choosing the number of components with the smallest RMSE. However, the `caret` package can simplify this process considerably using the `train` function. We need to include the same parameters as in the function call to `plsr`, along with a few additional parameters. We specify `method = "pcr"` since `train` can handle many different model types, `trControl = trainControl("cv", number = 10)` to indicate that we want 10-fold cross-validation, and `tuneLength = 10` to indicate that we want to test values from 1 to 10 for the `ncomp` parameter.

```{r pls_cv, message=FALSE}
library(caret)

#set seed for reproducibility, since CV involves random partitions
set.seed(300)
 
pls_cv <- train(shares ~ ., data = news_cl, scale = TRUE, center = TRUE, 
               method = "pcr", trControl = trainControl("cv", number = 10), 
               tuneLength = 10)

plot(pls_cv)

pls_cv$bestTune
```

From cross-validation, we see that two components is the best choice, and that including more than that may lead to overfitting.

More info on the `caret` package can be found [here](http://topepo.github.io/caret/index.html).

### Pros & Cons

PLS can perform well for prediction when there are many features, even when multicollinearity is present, violating the assumptions for ordinary least squares (OLS). Multicollinearity occurs when some predictor variables are highly correlated with some combination of other predictor variables, and occurs increasingly often as the number of predictor variables grows. Therefore PLS can be useful for prediction with high-dimensional data (when the number of predictors $p$ is large relative to the number of observations $n$). However, PLS is less interpretable than OLS in understanding the underlying relationship between features and response, since it involves the creation of new features.

PLS generally has lower bias but higher variance than PCR.

PLS can have minor instability in its estimates because it tends to shrink low-variance directions but sometimes inflates high-variance directions. Ridge regression shrinks all directions, but especially low-variance directions, while PCR discards low-variance directions.

PLS, PCR, and ridge regression typically perform very similarly, but for minimizing prediction error, ridge regression is generally preferred because it shrinks smoothly as opposed to in discrete steps.

