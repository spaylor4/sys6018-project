---
title: "Improving Least Squares"
author: "Rachel Filderman, Latifa Hasan, Emily Murphy, Shannon Paylor"
date: "12/8/2020"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: cosmo
---

```{r packages, include=FALSE}
library(tidyverse)
library(caret)
library(leaps)
```

# Introduction

Have you recently mastered the introductory concepts in producing statistical models? Congratulations! With this knowledge, it’s now time to consider fine tuning model parameters further in order to improve the ordinary least squares (OLS) approach. One way we can do this is by determining if all of the parameters or variables are important in our model or if we instead can produce a better model after reducing the variables in the model through feature selection. You were likely introduced to subset selection in an introductory statistical model course, but there are other methods, as well, to improving OLS with feature selection. We will cover the following techniques in this tutorial with respect to the each method’s motivation and algorithm:

1. Subset Selection
    + Best Subsets
    + Stepwise Selection/Elimination
2. Penalized Regression
    + Ridge
    + Lasso
    + Elastic Net
3. Dimension Reduction
    + Principal Component Analysis (PCA)
    + Partial Least Squares (PLS)

In addition, we will demonstrate these techniques through a coding example with the following dataset.

Before we dive into dimension reduction, let's refresh a few key concepts.

### Review:
**Supervised vs Unsupervised Learning:** supervised learning involves modeling a response variable on one or more features, while unsupervised learning involves finding underlying structure in data features without relating to a predictor variable.

**Response Variable:** the variable of interest in a prediction problem, usually denoted $Y$.

**Features/predictor Variables:** data used in modeling, usually denoted $X$. In a supervised learning problem, these features are used to predict the response variable.

**Standardizing Variables:** re-scaling variables to have mean zero and variance one. Standardizing can be especially important when variables are on widely differing scales (e.g. one feature on a percentage scale with values between zero and one and another feature measured in dollars on a scale from zero to several thousand).

**Bias & Variance:** bias is a measure of how far the mean/expected value of an estimator is from the true value, or $E(\hat Y) - Y$. Variance is a measure of how much the squared expected value of an estimator differs from the expected value of the squared estimator, or $E(\hat Y^2) - E(\hat Y)^2$. In other words, bias measures the error in the center of the estimate, and variance measures the error in the spread of the estimate. Generally, as model complexity increases, bias increases and variance decreases. This is frequently referred to as the bias-variance tradeoff.

**Model Selection Criteria:** Model selection criteria are used to evaluate and compare subset regression models. Common criteria used include: 

* Adjusted $R^2$ = $1-(\frac{n-1}{n-p})(1-R^2_p)$
* Akaike Information Criterion (AIC) = $ -2ln(L)+2p$, where L is the likelihood function for a specific model
* Bayesian Information Criterion (BIC) = $-2ln(L)+p*ln(n)$
* Mean Square Error (MSE) = $\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y}_i)^2$
	
### Why improve on least squares?
OLS is not well-suited to high dimensional data. When the number of predictors $p$ is greater than the number of observations $n$, it will be possible to create a model explaining 100% of the variance in the data, which will usually lead to overfitting and poor prediction for new data.

### Real Life Applications:
+ DNA Sequencing
+ GDP 
+ Housing prices


# Subset Selection


One method of improving the ordinary least squares regression is by selecting a subset of the predictor variables to train the model based on how the model performs. Having fewer predictor variables improves the ability to interpret the model because it is easier to view the relationship between the response variable and the predictors. Fewer variables would also decrease the risk of overfitting the model on the training data. The predictor variables are selected based on their performance on OLS, and only the predictors that improve performance are used. The two main processes for choosing which variables to include are best subsets and stepwise regression.

## Best Subsets 
One method of finding the best subsets is by testing all possible combinations of these predictors to determine which model performs the best, and the combination of predictors that performs the best is selected to be used. Best subsets returns the best model for each number of predictors included, so the best model with one predictor, with two predictors, and so on. A model is typically defined as performing better if it has the minimum MSE, or residual sum of squares, values, but any of the model selection criteria reviewed above may be used. The different model selection criteria may select different combinations of predictors as performing the “best”, so it is valuable to consider multiple options. While this process is simple to implement, the time to calculate all the combinations exponentially increases as the number of potential predictors increases. For example, a model with 10 predictors has 1024 possible combinations. Therefore, this may only be possible if the data includes a small number of variables. It is possible to arbitrarily select the maximum number of predictors to include, but the time to calculate the best predictors to use may still take too long to work as a viable solution. The user must also review the best models for each number of predictions and choose the best one based on the results and context of the problem.


## Stepwise-type Procedure 
Stepwise-type procedures determine which predictor variables to include by adding or deleting predictors one at a time; the process evaluates fewer models and is less computationally burdensome than comparing all possible subsets. Three categories of stepwise-type procedures include forward selection, backward elimination, and stepwise regression (which is a combination of the previous two).

![](https://media1.tenor.com/images/c7e74eab5f3eab4d39e582ed6d972836/tenor.gif?itemid=16521383)

**Forward Selection:** The initial model includes only the intercept value and no predictors. Predictors will be added to the model one at a time, as long as the F statistic is greater than a preselected F value called $F_{IN}$. Most programs utilize a default $F_{IN}$, so this does not need to be set in order to perform the calculation. The first predictor added to the model is the one with the largest correlation with the response variable; this predictor also generates the most significant F statistic. The F statistic must exceed $F_{IN}$ to be added to the model. For the second step, the next predictor selected will have the highest correlation with the response variable, given the presence of the first predictor. The partial F (or t) statistic for the second predictor must also exceed $F_{IN}$. If $F_{IN}$ is larger, then the predictor is not added to the model and no further predictors are considered to be added to the model. Step 2 is repeated until the partial F statistic of the predictor to be added is less than $F_{IN}$ or until all predictors have been added to the model.

**Backward Elimination:** The initial model for backward elimination begins with all of the predictor variables included in the model and drops them one by one until a suitable model is found. This method is preferred if you want to confirm all predictors have been considered and nothing was missed. Backward elimination determines if predictors should be dropped by comparing the partial F (or t) statistic to a preselected value $F_{OUT}$. Similar to $F_{IN}$, programs will use a default value for $F_{OUT}$. The first step of implementing backward elimination is to calculate the partial F statistic for all the predictors. The smallest partial F statistic is compared to $F_{OUT}$ and if it is smaller than $F_{OUT}$, then that predictor is removed from the model. The partial F statistics are recalculated given the updated model, and the smallest partial F statistic for the new model is compared to $F_{OUT}$. The process of removing predictors will continue until the smallest partial F statistic exceeds $F_{OUT}$.

**Stepwise Regression:** Stepwise regression is a combination of forward selection and backward elimination. The initial model assumes only the intercept is included, and predictors are added one at a time. The difference is after a predictor is added, all the predictors in the model will be reviewed to determine if they should still be included. In this method, both $F_{IN}$ and $F_{OUT}$ must be preselected. There is no required relationship between $F_{IN}$ and $F_{OUT}$. Some people prefer to set the two values equal to each other; others would rather set $F_{IN}$ > $F_{OUT}$ so it is more difficult to add a predictor than drop one.

The initial model is the same as forward selection, and each predictor added must meet the same criteria as outlined in forward selection. After adding a new predictor, the partial F statistic is calculated for each of the predictors in the model, and the partial F statistic is compared to $F_{OUT}$. One important difference is all partial F statistics less than $F_{OUT}$ will be dropped, while only the smallest partial F statistic is dropped in backward elimination. The model will be complete when the partial F statistic for adding a predictor is less than $F_{IN}$.


### Code Implementation
We will show how to implement the various methods using an online news popularity data set. The data set includes 58 predictors and 39644 rows of observations. Examples of the predictors include number of words in the title, number of words in the article, a binary value for each day of the week, and average polarity of the words used. The two non-predictive columns we removed are url and timedelta, which is the time between the article being published and being added to the dataset. The goal is to determine which of the 58 predictors are most useful in using linear regression to find the number of times an article is shared. 

The code below shows how to perform all three of the stepwise procedures. The output in R typically shows detailed steps of the different models, but only the summaries have been included here.


```{r, results='hide', cache = TRUE}
# Load the data
news = read.csv('OnlineNewsPopularity.csv') %>% select(-url, -timedelta)

# Define intercept only model
regnull <- lm(shares~1, data=news)
# Define model with all predictors
regfull <- lm(shares~., data=news)
# Perform Forward Selection, start with regnull
forward_selection = step(regnull, scope=list(lower=regnull, upper=regfull), direction="forward")
# Perform Backward Elimination, start with regfull
backward_elimination = step(regfull, scope=list(lower=regnull, upper=regfull), direction="backward")
# Perform Stepwise Regression, start with regnull
stepwise_regression = step(regnull, scope=list(lower=regnull, upper=regfull), direction="both")
```

```{r}
# Results from Forward Selection
summary(forward_selection)
# Results from Backward Elimination
summary(backward_elimination)
# Results from Stepwise Regression
summary(stepwise_regression)

```


**Results**

As seen above, the three stepwise-type procedures do not give the same results as each other. Forward selection and stepwise regression have the same output in this scenario, but it is not guaranteed the results from forward selection and stepwise regression would be equal for a different model. Backward elimination includes 2 more predictor variables than the other two methods, which results in a higher adjusted $R^2$ value. The residual standard errors are the same, and this shows how different combinations of predictors can have similar performances. It is valuable to perform all three of these processes and pick a model based on the context of the problem.

### Pros & Cons

**Pros**

1. Subset selection is easy to implement and may work with categorical and continuous predictors.

2. The coefficients assigned to the predictors selected using subset selection are easy to interpret, which is useful for inference problems.

3. The three stepwise-type procedures are able to be used when there are many predictors.


**Cons**

1. When there are a large number of predictors possible, the time to run the best subset formula can become restrictive.

2. Results of the best subset and stepwise-type procedure may vary based on the model selection parameters used. 

3. If the number of observations is small, then a small change in the data may result in a significant change to the model.

4. These methods only work for supervised learning problems.



# Penalized Regression

The subset method focuses on using least squares to improve on regression using an “all or nothing” approach. The results from the subset selection methods can vary based on the model used, and the methods in subset selection are not often robust to data of all sizes. rendering the subset selection method unstable. Shrinkage methods are useful in cases where subset selection methods are unstable. Shrinkage methods shrink the coefficients closer to 0 to help improve model fit and predictive power by reducing the variance of the coefficient estimates generated. Shrinkage accomplishes this by using a penalized regression method, where a penalty is imposed for having many variables in the model. Penalized regression methods are available for linear and logistic regression depending on the type of outcome we are trying to predict. 

There are three well known methods for penalized regression: ridge, lasso, and elastic net. Each method imposes the penalty by using a tuning parameter called $\lambda$, the $\lambda$ value is usually selected using cross-validation. The minimum $\lambda$ value generated is the best tuning parameter used in each of the models. The primary difference in the three methods is in their choice of $\alpha$. Ridge regression uses an $\alpha$ value of 0 and lasso regression uses an $\alpha$ value of 1. Elastic net regression provides the flexibility to choose an $\alpha$ value between 0 and 1. 

### Code Implementation

The code below is a demonstration of implementing penalized regression using ridge, lasso, and elastic net regression methods. Since penalized regression aims to improve predictive power of regression models, we determine the predictive performance of each of the three regression methods. In order to generate predictions, we begin by splitting our dataset into train and test data. The train data will be used to build the models, whereas the predictions will be made on the test data. Two parameters, RMSE, Root Mean Squared Error, and $R^2$ will help to determine the performance of each of the three models.The glmnet package in R is very efficient for fitting ridge, lasso, and elastic net models, for both penalized linear and logistic regression models. 

#### Import the libraries 

```{r, message=FALSE}
library(tidyverse)  #for data visualization and manipulation
library(MASS)  #for ridge regression 
library(broom)
library(glmnet)  #for ridge, lasso, and elastic net regression 
library(caret)  #to partition data into train and test sets 
```

#### Exploratory analysis on the data

The summary of the dependent variable shows that it has a wide range of values ranging from 1 - 843,300, with a mean of 3395. 

```{r}
#Import the dataset 
news = read.csv("OnlineNewsPopularity.csv")

#Drop non-predictive variables from the dataset
news = subset(news, select = -c(url,timedelta))

summary(news$shares)
```

```{r}
#Split the data into train and test data 
set.seed(123)
split = sort(sample(nrow(news), nrow(news)*.8)) #80% train samples 
train<-news[split,]
test<-news[-split,]
```

We will compute the penalized linear regression on the train data set. 

```{r}
#Specify the predictor and response variables 
#y is the response variable --> shares
y.train <- train$shares

#x is the matrix with the predictor variables 
x.train <- model.matrix(train$shares~., train)

#Remove the intercept column that X.train generates intercept in the first column
x.train = x.train[,-1]
```

**Ridge Regression**

The set up of a ridge regression model begins by setting up the 10-fold cross-validation model to determine the tuning parameter, $\lambda$. The cross-validation model is set up by using the glmnet package in R. The parameters needed to compute the $\lambda$ value include $\alpha$ = 1, and the number of cross-validation folds. Ridge regression has a lower mean square prediction error compared to least squares. When $\lambda$ is 0, the variance is the same as that computed by least squares. As $\lambda$ increases, the variance decreases, when $\lambda$ approaches $\infty$, the variance  approaches closer to 0. 

In order to compute ridge regression, we set the $\alpha$ value to 0. The glmnet package fits the model and computes the tuning parameter, $\lambda$. 

```{r}
# Find the best lambda using cross-validation
set.seed(202) 
cv_ridge <- cv.glmnet(x.train, y.train, alpha = 0)
# Display the best lambda value
cv_ridge$lambda.min   

# Fit the ridge regression model on the training data
ridge <- glmnet(x.train, y.train, alpha = 0, lambda = cv_ridge$lambda.min)
# Display regression coefficients
coef(ridge)
```

Next, we will use the ridge regression model constructed with the train data to make predictions on the test data. 

```{r}
# Make predictions on the test data
x.test <- model.matrix(test$shares ~., test)#[,-1]

#Drop the first column from the x.test matrix which is the intercept
x.test <- x.test[,-1]

predictions_ridge <- ridge %>% predict(x.test)

# Model performance metrics
RMSE_ridge = RMSE(predictions_ridge, test$shares)
Rsquare_ridge = R2(predictions_ridge, test$shares)
data.frame(RMSE = RMSE_ridge, R2 = Rsquare_ridge)
```

**Pros**

1. The ridge penalty decreases the variance of the data. A decreased variance allows for better model performance. However, decrease in variance increases the bias. The bias-variance trade off allows for improved model performance. 
2. The computational efficiency of ridge regression is higher compared to subset selection. 

**Cons**
1. The ridge penalty increases bias in the model.
2. The ridge penalty includes all predictors in the model, unlike subset selection methods where a subset of the predictor variables are considered, not giving the user a chance to create a model using a subset of variables. 
3. The ability to interpret from models produced using a ridge penalty is not very high. 


**Lasso Regression**

The set up of a lasso penalty is very similar to that of the ridge penalty. We set up a 10-fold  cross-validation model to determine the tuning parameter $\lambda$. Similar to ridge regression, we use the glmnet package in R to compute the $\lambda$ value. As mentioned earlier, the key difference between ridge and lasso is the choice of $\alpha$. An $\alpha$ value of 1 is used to construct a lasso model along with the specified number of cross-validation folds. One advantage of lasso over ridge is that lasso can shrink coefficients completely to 0, unlike the ridge penalty that shrinks coefficients close to 0. Shrinking coefficients down to 0 removes unhelpful predictor variables from the model. This is similar to the subset selection method where only a subset of the predictor variables are considered. 

In order to compute lasso regression, we set the $\alpha$ value to 1. The glmnet package fits the model and computes the tuning parameter, $\lambda$. 

```{r}
# Find the best lambda using cross-validation
set.seed(202) 
cv_lasso <- cv.glmnet(x.train, y.train, alpha = 1)
# Display the best lambda value
cv_lasso$lambda.min  

# Fit the ridge regression model on the training data
lasso <- glmnet(x.train, y.train, alpha = 1, lambda = cv_lasso$lambda.min)
# Display regression coefficients
coef(lasso)
```

Next, we will use the lasso regression model constructed with the train data to make predictions on the test data. 

```{r}
# Make predictions on the test data
predictions_lasso <- lasso %>% predict(x.test)

# Model performance metrics
RMSE_lasso = RMSE(predictions_lasso, test$shares)
Rsquare_lasso = R2(predictions_lasso, test$shares)
data.frame(RMSE = RMSE_lasso, R2 = Rsquare_lasso)
```

**Pros**

1. The lasso penalty can remove unhelpful predictors from the model by setting their coefficients to 0, leaving only useful predictors to improve predictive power. 

2. Models generated using the lasso penalty have better interpretability compared to the ridge penalty. 

3. Lasso regression is also much more computationally efficient compared to the subset selection method. 

4. Lasso regression, like ridge regression, has a bias-variance trade-off, and decreases variance, thus improving model performance. 

**Cons**

1. Since the lasso penalty removes predictors, it increases bias by only incorporating certain predictors. 

From the description and results above, we can see that the both ridge and lasso penalties have slight differences, but have similar performance, and one does not outperform the other in all aspects. 

**Elastic Net Regression**

The elastic net regression penalty is slightly different than the lasso and ridge penalties. Here the $\alpha$ value can be between 0 and 1. A random $\alpha$ value between 0 and 1 can be chosen, or the caret package in R can help automatically select the best $\alpha$ and $\lambda$ parameters. A combination of the best $\alpha$ and $\lambda$ minimizes the error rate. 

**Pros**

1. Elastic net avoids hard coding the $\alpha$ value and automatically selects the best combination of $\alpha$ and $\lambda$ values to fit the model. The RMSE and $R^2$ values are the lowest for the elastic net model, indicating that it performs better than the lasso and ridge regression models, since it results in the least prediction error. 

**Cons**

1. The elastic net model is computationally inefficient in comparison with lasso and ridge regression. 

Elastic net can be computed using two methods. The first method will automatically compute the best alpha and lambda values. 

```{r}
#Define the model and find the best lambda using 10-fold cross validation 
set.seed(202)
elasticnet <- train(shares ~., data = train, method = "glmnet", trControl = trainControl("cv", number = 10),  tuneLength = 10)

#Compute coefficients for the model 
coef(elasticnet$finalModel, elasticnet$bestTune$lambda) 
#above we are getting coefficients for the best model 
```

Elastic net can also be computed using glmnet directly in R. Here we need to specify an $\alpha$ value of our choice, and the model computes the best lambda value. 

```{r}
# Find the best lambda using cross-validation
set.seed(202)
cv_elasticnet = cv.glmnet(x = x.train, y=train$shares, alpha=0.8)
lambda.hat = cv_elasticnet$lambda.min
lambda.hat  

# Fit the elastic net regression model on the training data
elasticnet_glm <- glmnet(x.train, y.train, alpha = 0.8, lambda = cv_elasticnet$lambda.min)
# Display regression coefficients
coef(elasticnet_glm)
```

Next, we will use the elastic net regression model constructed with the train data to make predictions on the test data. 

```{r}
#Predictions on the test data 
predictions_elasticnet <- elasticnet %>% predict(x.test)

# Evaluate the model performance using RMSE and R2 metrics
RMSE_1 = min(elasticnet$results$RMSE)  
Rsquare_1 = min(elasticnet$results$Rsquared)
data.frame(RMSE = RMSE_1, R2 = Rsquare_1)
```

**Performance for all 3 models**

As we can see, all 3 models easily generate predictions using the glmnet package in R. In terms of model performance, we can see that the best RMSE generated using the elastic net penalty is lower than the ridge and lasso models. Both ridge and Lasso models have very close RMSE and $R^2$ values, whereas the elastic net method outperforms them in terms of RMSE. Penalized regression is easy to compute and is most helpful when we have large datasets that are multivariate. It is recommended to compute all 3 models and to proceed with the model specific to the problem and the one that produces the best predictions with the lowest RMSE. 

# Dimension Reduction

In the methods described so far, we have focused on feature selection and eliminating features that we decide are not significant enough for our model. However, in entirely dropping these features - however insignificant they may be - we completely miss out on any benefits these dropped variables may contribute. Instead, we could incorporate all variables strategically in order to extract as much information as possible using dimension reduction. Dimension reduction entails creating an $M$-dimensional subspace where $M$ combinations are constructed as a combination of $p$ predictors. The $M$ combinations of predictors are then used to fit a least squares linear regression model. In order to benefit from this approach, $M < p$ must hold. If $M = p$, then the resulting model amounts to using a least squares fit using all of the original predictors. We especially benefit from this approach when $p$ (number of predictors) is large relative to n (number of observations), as using $M < p$ can reduce the variance of the model. 

Dimension reduction methods generally follow two steps:  
1. Obtain the transformed predictors $Z_1$, $Z_2$,...$Z_M$  
2. Fit the model using these predictors

In the following sections, we will discuss two popular methods for dimension reduction: Principal Component Analysis (PCA) and Partial Least Squares (PLS).


## Principal Components Analysis (PCA)

Principal Components Analysis is a dimension reduction technique in which variables named principal components are constructed as linear combinations of our original variables. There are as many principal components created as there are original variables in our data. However, in order to attain a model with reduced dimensions, we will aim to drop a number of these principal components. To determine which principal components can be excluded from our model, we will  rank the principal components by their importance in predicting the response variable. Then, only the most important principal components are used in the linear model. 

We will likely want to use this method when we seek to reduce the number of variables, but do not know which ones. However, we will see that one drawback of this method is its interpretability, as we are no longer using our original predictors to predict the response but are instead using transformed predictors that each include all of our original predictors. 

Before we dive into the algorithm and steps behind PCA, it will be helpful to review how and why we use variance to rank principal components by importance.

### Constructing Principal Components

Principal components represent the directions of the data that explain a maximal amount of variance. In understanding this method, it’s important to recognize that variance explained is equivalent to information captured in a model. The more variance in the data that we can explain through a feature, the better.

The image below will help explain how this concept ties into principal component analysis. 

![(Source: Z, Jaadi, “A Step-by-Step Explanation of Principal Component Analysis.)](https://builtin.com/sites/default/files/inline-images/Principal%20Component%20Analysis%20second%20principal.gif)

The goal of principal component analysis is to compress as much information or variance in the first components, and thus the first principal component accounts for the largest variance in the dataset. 

In the scatterplot above, we aim to construct a principal component or line that maximizes this variance, which is when the red dots are spread out the most along the line. This line then represents more variance and the larger the variance represented by a line, the larger the dispersion of points along a line, and thus the more information the line holds.

Now that we understand how these principal components contribute to our model, let’s walk through the steps taken to construct the principal components. 

### Algorithm Behind the Method:

1. Center and standardize our original predictor variable matrix, $X$.  
    + This method is sensitive to variance in the predictor variables, so this step is necessary to ensure each variable contributes equally to the model  
2. Compute the covariance matrix by multiplying the transpose of this standardized matrix by itself.  
    + Thus, where X has been standardized: $X^TX$  
3. Compute the eigenvectors and eigenvalues of the covariance matrix, $X^TX$.  
    + Let’s pause here for a refresher on linear algebra:  
        + Eigenvectors represent directions and eigenvalues represent magnitude (or in this scenario, importance). Eigenvectors are stored in a dense matrix while eigenvalues are stored in a matrix with eigenvalues on the diagonal and zeros everywhere else. These eigenvalues on the diagonal are associated with the corresponding column in the eigenvector matrix. For example, an eigenvalue stored on the diagonal in the second column of its matrix corresponds to the second column in the eigenvector matrix.  
        + Luckily, there are functions in R that will compute these values for us, but it’s important to understand the eigenvectors and eigenvalues it outputs.  
        
![](https://media.giphy.com/media/ZThQqlxY5BXMc/source.gif)

4. Sort the eigenvalues from largest to smallest  
    + Since eigenvalues correspond to their eigenvectors, the eigenvectors are similarly sorted according to the order of their corresponding eigenvalue (put another way, the columns of the eigenvector matrix are reordered according to the reordering of the eigenvalue matrix).  
5. Multiply this sorted eigenvector matrix by the standardized version of X from step 1.  
    + As a result, we now have a standardized version of X with weights determined by the eigenvectors.  
6. With this new matrix, determine how many features (principal components) to keep in the new feature matrix. This can be done a couple of ways:  
    a) Arbitrarily determine how many dimensions to keep:  
        + This is not recommended, but at times may be appropriate for your specific analysis or problem  

    b) Set a threshold for proportion of variance explained:  
        + As explained earlier, the importance of a principal component or eigenvector is tied to variance. Further, each eigenvalue is approximately the importance of its corresponding eigenvalue (as we saw when sorting our eigenvalues and then eigenvectors). Therefore, we can create a metric for measuring the importance or variance explained by each principal component or eigenvector called the proportion of variance, which is the sum of all eigenvalues kept divided by the sum of all eigenvalues.  
        + With this metric, we can then pick a threshold of proportion of variance explained and include principal components up until we reach the set threshold.
 
     c) Use a scree plot:  
        + Similar to the method above, we can use the proportion of variance to determine how many principal components to keep.     
        + We calculate the proportion of variance for each principal component, sort the principal components by proportion of variance explained (though they technically should already be sorted in order of importance), then plot the proportion of variance explained by each principal component.  
        + We should then have a line plot with an elbow that denotes the point at which there is the largest drop in proportion of variance explained. We then decide to use the principal components up until this drop. In the scree plot below, there is a considerable drop between proportion of variance explained in PC1 to PC2. We would therefore identify PC2 as the elbow and only include the first feature (PC1) and drop the rest. As you can see, a disadvantage of this method is that it is relatively subjective.

![(Source: https://datavizpyr.com/how-to-make-scree-plot-in-r-with-ggplot2/)](https://i2.wp.com/datavizpyr.com/wp-content/uploads/2020/08/Scree_plot_with_geom_line_ggplot2.png?w=600&ssl=1)

7. Use this new feature matrix with the principal components/eigenvectors we chose to keep as the new X in our linear regression model against the untransformed Y -- this type of regression using PCA is known as Principal Components Regression (PCR).  

    + Note: Each of these new variables resulting from PCA are all independent of each other, which is an important assumption that must hold for a linear model.
    
### Code Implementation

```{r, include=FALSE}
library(dplyr)
set.seed(123)
```
There are a couple of libraries you can use for PCR - one is `pls` which also can be used for PLS (covered next). We'll first show how to run PCR using this library:
```{r, message=FALSE}
library(pls)
```
Run PCR with cross-validation:
```{r}
pcr.fit = pcr(shares~., data = news, scale=TRUE, validation ="CV")
```
In the above code, `scale` is set to `TRUE` in order to standardize each predictor. `validation` is set to `CV` in order to compute ten-fold cross-validation error for each possible value of M (the number of principal components used). Having the cross-validation error will give us another metric to judge principal components by.

Summary:
```{r}
summary(pcr.fit)
```
From this summary, we see that the smallest RMSE is at 55 components (M=55), at which point 100% of variance is explained.

More info on the `pls` package is available [here](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf).


Next, we can use the function `prcomp()` within the core stats package for PCR. The difference in setting up `pcr()` vs. `prcomp()` is that `prcomp()` needs the data passed in with no response variable. Therefore, we create an `X` from our data, removing our response variable, `shares`.
```{r, message=FALSE}
X = news %>% dplyr::select(-shares)

prcomp.fit = prcomp(X, scale = TRUE)

summary(prcomp.fit)
```
Similar to `pcr()`, we have a summary table with all PCs. Instead, here we have Proportion of Variance and Cumulative Proportion available to us. 

Next, visualize eigenvalues (scree plot). We will use `fviz_eig` located within the `factoextra` package. Show the percentage of variances explained by each principal component. 58 is passed in for `ncp` in order to visualize all PCs. If you would like to view less, you can change this input.
```{r, message=FALSE}
library(factoextra)
fviz_eig(prcomp.fit, ncp = 58)
```
At this point, we could have either chosen a threshold for proportion of variance explained or rely on finding an elbow in the scree plot. Let's say we chose a threshold of 85% proportion of variance explained. We would then see that we need to add components up until PC26 (including PC26) in order to meet this threshold, and would therefore keep the PCs up until and including PC26 in the model. In contrast, if we were to use the scree plot to find the elbow, there is arguably a large drop around PC5, at which point only 31% of variance is explained. Even if we were to continue until the next drop and elbow at PC12, only 58% of variance is explained.  

More info on the `prcomp` is available [here](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/prcomp.html).

More info on the `factoextra` package is available [here](https://cran.r-project.org/web/packages/factoextra/factoextra.pdf).

## Partial Least Squares (PLS)

Partial least squares (PLS) is very similar to principal components regression (PCR), in that both generate a new set of features that are linear combinations of the original features. However, unlike PCR, PLS incorporates information from the response variable when creating these new features. In doing so, PLS attempts to identify directions that explain the most variance in both the features and the response, rather than just explaining the variance in the features. Because PCR only considers the variance in the features, it may not be best for prediction, particularly if there is some variance in the features unrelated to the variance in the response.

PLS can be thought of as a supervised alternative to PCR's unsupervised approach. This is not to say that PCR cannot be used for supervised learning problems (it can be used for either supervised or unsupervised problems), but instead describes the method of generating the new features. PLS, on the other hand, can only be used for supervised problems, since the response variable is used in the creation of the new features.

![](https://media.giphy.com/media/ehVD71SQYsCHWrWgvs/giphy.gif){width=50%}

### Algorithm

PLS generates new features $Z$ that are linear combinations of the original features $X$. This means that the $m$th new feature can be written as $Z_m = \sum_{j = 1}^p \phi_{jm}X_j$, where $p$ is the total number of original features.

This process for creating these new features is as follows:

1. Standardize all features.

2. Initialize $X^{(0)} = X$ and $m=1$.

3. Compute the first direction $Z_1$ by setting $\phi_{j1}$ equal to the coefficient of ordinary least squares linear regression between $Y$ and $X_j$. In doing so, the $X_j$'s most highly correlated with $Y$ receive the highest weights in $Z_1$.

4. Orthogonalize $X$ with respect to $Z_1$ by regressing each variable $X_j$ on $Z_1$ and taking the residuals. Denote these orthogonalized values $X^{(1)}$. This means that $X^{(1)}$ is essentially the information not already explained by the first direction.

5. Repeat steps 2-4 to calculate each $Z_m$ for $m = 2, ..., p$, using the orthogonalized $X^{(m-1)}$ output from the previous step instead of $X$ to generate $Z_m$. So $X^{(1)}$ is used to calculate $Z_2$, $X^{(2)}$ is used to calculate $Z_3$, and so on.

6. Use ordinary least squares to regress $Y$ on $Z_1, ..., Z_m$ for some $m \le p$. Generally use cross-validation to choose the best value of $m$.

### Code Implementation

To implement PLS in R, we can use the `pls` package. After loading the package, the basic syntax for fitting PLS regression is very similar to that of linear regression with the `lm` function, though in this case we will use the `plsr` function. The first argument is a formula to tell the function what the response and predictor variables are. In this case, we're using online news data with `shares` as the response and all other variables as predictors. To avoid having to type out 58 variables in the formula, we can instead use `shares ~ .` to indicate that all columns besides `shares` should be treated as predictor variables. Additionally, to standardize the predictors, we can specify `scale = TRUE` and `center = TRUE`.

```{r fit_pls, message=FALSE}
#load the pls library
library(pls)

#fit the pls regression
pls_fit <- plsr(shares ~ ., data = news, scale = TRUE, center = TRUE)

summary(pls_fit)
```

The summary of the fit shows the percentage of variance explained by each additional component. In this example, we see that five components explain 24% of the variance in the data, and 10 components explain 38% of the variance in the data. 

We can also make predictions for new data using our PLS model. As with fitting the model, this process is very similar to ordinary least squares regression. We will use the `predict` function, but will need to include an additional parameter `ncomp` to specify the number of components to include.

More info on the `pls` package is available [here](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf).

```{r pred_pls}
#predict for given number of components (3 in this case)
predict(pls_fit, ncomp = 3, newdata = news[39640:39644,])
```

While the percentage of variance explained gives us some information about how many components to include, best practice is to choose this number using cross-validation. One method of cross-validation would involve a double for loop to iterate through subsets of the data and number of components, making predictions and calculating an error measure (generally root mean squared error for numeric predictor variables) for each combination, then choosing the number of components with the smallest RMSE. However, the `caret` package can simplify this process considerably using the `train` function. We need to include the same parameters as in the function call to `plsr`, along with a few additional parameters. We specify `method = "pcr"` since `train` can handle many different model types, `trControl = trainControl("cv", number = 10)` to indicate that we want 10-fold cross-validation, and `tuneLength = 10` to indicate that we want to test values from 1 to 10 for the `ncomp` parameter.

```{r pls_cv, message=FALSE}
library(caret)

#set seed for reproducibility, since CV involves random partitions
set.seed(300)
 
pls_cv <- train(shares ~ ., data = news, scale = TRUE, center = TRUE, 
               method = "pcr", trControl = trainControl("cv", number = 10), 
               tuneLength = 10)

plot(pls_cv)

pls_cv$bestTune
```

From cross-validation, we see that two components is the best choice, and that including more than that may lead to overfitting.

More info on the `caret` package can be found [here](http://topepo.github.io/caret/index.html).

### Pros & Cons

PLS can perform well for prediction when there are many features, even when multicollinearity is present, violating the assumptions for ordinary least squares (OLS). Multicollinearity occurs when some predictor variables are highly correlated with some combination of other predictor variables, and occurs increasingly often as the number of predictor variables grows. Therefore PLS can be useful for prediction with high-dimensional data (when the number of predictors $p$ is large relative to the number of observations $n$). However, PLS is less interpretable than OLS in understanding the underlying relationship between features and response, since it involves the creation of new features.

PLS generally has lower bias but higher variance than PCR.

PLS can have minor instability in its estimates because it tends to shrink low-variance directions but sometimes inflates high-variance directions. Ridge regression shrinks all directions, but especially low-variance directions, while PCR discards low-variance directions.

PLS, PCR, and ridge regression typically perform very similarly, but for minimizing prediction error, ridge regression is generally preferred because it shrinks smoothly as opposed to in discrete steps.

## Conclusion

In summary, it is important to consider the number of predictors being used to fit your model in OLS. Commonly, not all predictors are necessary and instead can lead to overfitting. We have outlined a few methods for either removing or transforming these predictors and unfortunately, one method is not always going to be the best method - it depends on the context of your data and the problem. Ridge does tend to most frequently outperform the others, but it's important to use discretion and due diligence to test or consider a couple methods, and then perhaps compare the resulting models using MSE. 

We hope you've enjoyed our tutorial!

![](https://media.giphy.com/media/uWlpPGquhGZNFzY90z/giphy.gif){width=50%}


## References 

[1] G. James, D. Witten, T. Hastie, and R. Tibshirani, An Introduction to Statistical Learning with Applications in R. New York: Springer, 2013.

[2] T. Hastie, J. Friedman, and R. Tisbshirani, The Elements of Statistical Learning: Data Mining, Inference, and Prediction, 2nd ed. New York: Springer, 2009.

[3] R. Merrett, “Online News Popularity.” Available: https://code.datasciencedojo.com/datasciencedojo/datasets/tree/master/Online News Popularity [Accessed: 03-Dec-2020].

[4] M. Brems, “A One-Stop Shop for Principal Component Analysis.” Available: https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c. [Accessed: 04-Dec-2020].

[5] D. Montgomery, E. Peck, and G. Vining, Introduction To Linear Regression Analysis. 5th ed. Wiley, 2012.

[6] Z, Jaadi, “A Step-by-Step Explanation of Principal Component Analysis.” Available: https://builtin.com/data-science/step-step-explanation-principal-component-analysis. [Accessed: 05-Dec-2020].

[7] R. Tobias, “An Introduction to Partial Least Squares Regression.” Available: https://stats.idre.ucla.edu/wp-content/uploads/2016/02/pls.pdf. [Accessed: 03-Dec-2020].

[8] Kassambara, “Principal Component and Partial Least Squares Regression Essentials,” STHDA, 11-Mar-2018. [Online]. Available: http://www.sthda.com/english/articles/37-model-selection-essentials-in-r/152-principal-component-and-partial-least-squares-regression-essentials/. [Accessed: 07-Dec-2020].

[9] B.-H. Mevik and R. Wehrens, “Introduction to the pls Package,” 04-Aug-2020. [Online]. Available: https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf. [Accessed: 07-Dec-2020].

[10] M. Kuhn, “The caret Package,” 27-Mar-2019. [Online]. Available: http://topepo.github.io/caret/index.html. [Accessed: 07-Dec-2020].

[11] M. Porter, “Data Mining Lecture .” Data Mining Lecture . 10-Sept-2020, Charlottesville. https://mdporter.github.io/SYS6018/lectures/03-penalized.pdf

[12] J. Friedman et al., glmnet: Lasso and Elastic-Net Regularized Generalized Linear Models. 2020. https://CRAN.R-project.org/package=glmnet

[13] M. Porter, “Supervised Learning II Lecture .” 01-Sept-2020, Charlottesville. https://mdporter.github.io/SYS6018/lectures/03-penalized.pdf

[14] G. Elumalai, “Pros and cons of common Machine Learning algorithms,” Medium, Nov. 19, 2019. https://medium.com/@gokul.elumalai05/pros-and-cons-of-common-machine-learning-algorithms-45e05423264f [Accessed 07-Dec-2020].

[15] “Penalized Regression Essentials: Ridge, Lasso & Elastic Net - Articles - STHDA.” http://www.sthda.com/english/articles/37-model-selection-essentials-in-r/153-penalized-regression-essentials-ridge-lasso-elastic-net/ [Accessed 07-Dec-2020].

[16] A. Kassambara et al., factoextra: Extract and Visualize the Results of Multivariate Data Analyses. 2020. https://CRAN.R-project.org/package=factoextra 

