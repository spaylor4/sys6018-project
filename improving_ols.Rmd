---
title: "Improving Least Squares"
author: "Rachel Filderman, Latifa Hasan, Emily Murphy, Shannon Paylor"
date: "12/8/2020"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: cosmo
---

```{r packages, include=FALSE}
library(tidyverse)
library(caret)
library(leaps)
```

# Introduction

Have you recently mastered the introductory concepts in producing statistical models? Congratulations! With this knowledge, it’s now time to consider fine tuning model parameters further in order to improve the ordinary least squares (OLS) approach. One way we can do this is by determining if all of the parameters or variables are important in our model or if we instead can produce a better model after reducing the variables in the model through feature selection. You were likely introduced to subset selection in an introductory statistical model course, but there are other methods, as well, to improving OLS with feature selection. We will cover the following techniques in this tutorial with respect to the each method’s motivation and algorithm:

1. Subset Selection
    + Best Subsets
    + Stepwise Selection/Elimination
2. Penalized Regression
    + Ridge
    + Lasso
    + Elastic Net
3. Dimension Reduction
    + Principal Component Analysis (PCA)
    + Partial Least Squares (PLS)

In addition, we will demonstrate these techniques through a coding example with the following dataset.

Before we dive into dimension reduction, we will refresh a few key concepts.

### Review:
**Supervised vs Unsupervised Learning:** supervised learning involves modeling a response variable on one or more features, while unsupervised learning involves finding underlying structure in data features without relating to a predictor variable.

**Response Variable:** the variable of interest in a prediction problem, usually denoted $Y$.

**Features/predictor Variables:** data used in modeling, usually denoted $X$. In a supervised learning problem, these features are used to predict the response variable.

**Standardizing Variables:** re-scaling variables to have mean zero and variance one. Standardizing can be especially important when variables are on widely differing scales (e.g. one feature on a percentage scale with values between zero and one and another feature measured in dollars on a scale from zero to several thousand).

**Bias & Variance:** bias is a measure of how far the mean/expected value of an estimator is from the true value, or $E(\hat Y) - Y$. Variance is a measure of how much the squared expected value of an estimator differs from the expected value of the squared estimator, or $E(\hat Y^2) - E(\hat Y)^2$. In other words, bias measures the error in the center of the estimate, and variance measures the error in the spread of the estimate. Generally, as model complexity increases, bias increases and variance decreases. This is frequently referred to as the bias-variance tradeoff.

**Model Selection Criteria:** Model selection criteria are used to evaluate and compare subset regression models. Common criteria used include: 

* Adjusted $R^2$ = $1-(\frac{n-1}{n-p})(1-R^2_p)$
* Akaike Information Criterion (AIC) = $ -2ln(L)+2p$, where L is the likelihood function for a specific model
* Bayesian Information Criterion (BIC) = $-2ln(L)+p*ln(n)$
* Mean Square Error (MSE) = $\frac{1}{n}\sum_{i=1}^n(y_i-\hat{y}_i)^2$
	
### Why improve on least squares?
OLS is not well-suited to high dimensional data. When the number of predictors $p$ is greater than the number of observations $n$, it will be possible to create a model explaining 100% of the variance in the data, which will lead to overfitting and poor prediction for new data.

### Real Life Applications:
+ DNA Sequencing
+ GDP 
+ Housing prices


# Subset Selection


One method of improving the ordinary least squares regression is by selecting a subset of the predictor variables to train the model based on how the model performs. Having fewer predictor variables improves the ability to interpret the model because it is easier to view the relationship between the response variable and the predictors. Fewer variables would also decrease the risk of overfitting the model on the training data. The predictor variables are selected based on their performance on OLS, and only the predictors that improve performance are used. The two main processes for choosing which variables to include are best subsets and stepwise regression.

## Best Subsets 
One method of finding the best subsets is by testing all possible combinations of these predictors to determine which model performs the best, and the combination of predictors that performs the best is selected to be used. Best subsets returns the best model for each number of predictors included, so the best model with one predictor, with two predictors, and so on. A model is typically defined as performing better if it has the minimum MSE, or residual sum of squares, values, but any of the model selection criteria reviewed above may be used. The different model selection criteria may select different combinations of predictors as performing the “best”, so it is valuable to consider multiple options. While this process is simple to implement, the time to calculate all the combinations exponentially increases as the number of potential predictors increases. For example, a model with 10 predictors has 1024 possible combinations. Therefore, this may only be possible if the data includes a small number of variables. It is possible to arbitrarily select the maximum number of predictors to include, but the time to calculate the best predictors to use may still take too long to work as a viable solution. The user must also review the best models for each number of predictions and choose the best one based on the results and context of the problem.


## Stepwise-type Procedure 
Stepwise-type procedures determine which predictor variables to include by adding or deleting predictors one at a time; the process evaluates fewer models and is less computationally burdensome than comparing all possible subsets. Three categories of stepwise-type procedures include forward selection, backward elimination, and stepwise regression (which is a combination of the previous two).

![](https://media1.tenor.com/images/c7e74eab5f3eab4d39e582ed6d972836/tenor.gif?itemid=16521383)

**Forward Selection:** The initial model includes only the intercept value and no predictors. Predictors will be added to the model one at a time, as long as the F statistic is greater than a preselected F value called $F_{IN}$. Most programs utilize a default $F_{IN}$, so this does not need to be set in order to perform the calculation. The first predictor added to the model is the one with the largest correlation with the response variable; this predictor also generates the most significant F statistic. The F statistic must exceed $F_{IN}$ to be added to the model. For the second step, the next predictor selected will have the highest correlation with the response variable, given the presence of the first predictor. The partial F (or t) statistic for the second predictor must also exceed $F_{IN}$. If $F_{IN}$ is larger, then the predictor is not added to the model and no further predictors are considered to be added to the model. Step 2 is repeated until the partial F statistic of the predictor to be added is less than $F_{IN}$ or until all predictors have been added to the model.

**Backward Elimination:** The initial model for backward elimination begins with all of the predictor variables included in the model and drops them one by one until a suitable model is found. This method is preferred if you want to confirm all predictors have been considered and nothing was missed. Backward elimination determines if predictors should be dropped by comparing the partial F (or t) statistic to a preselected value $F_{OUT}$. Similar to $F_{IN}$, programs will use a default value for $F_{OUT}$. The first step of implementing backward elimination is to calculate the partial F statistic for all the predictors. The smallest partial F statistic is compared to $F_{OUT}$ and if it is smaller than $F_{OUT}$, then that predictor is removed from the model. The partial F statistics are recalculated given the updated model, and the smallest partial F statistic for the new model is compared to $F_{OUT}$. The process of removing predictors will continue until the smallest partial F statistic exceeds $F_{OUT}$.

**Stepwise Regression:** Stepwise regression is a combination of forward selection and backward elimination. The initial model assumes only the intercept is included, and predictors are added one at a time. The difference is after a predictor is added, all the predictors in the model will be reviewed to determine if they should still be included. In this method, both $F_{IN}$ and $F_{OUT}$ must be preselected. There is no required relationship between $F_{IN}$ and $F_{OUT}$. Some people prefer to set the two values equal to each other; others would rather set $F_{IN}$ > $F_{OUT}$ so it is more difficult to add a predictor than drop one.

The initial model is the same as forward selection, and each predictor added must meet the same criteria as outlined in forward selection. After adding a new predictor, the partial F statistic is calculated for each of the predictors in the model, and the partial F statistic is compared to $F_{OUT}$. One important difference is all partial F statistics less than $F_{OUT}$ will be dropped, while only the smallest partial F statistic is dropped in backward elimination. The model will be complete when the partial F statistic for adding a predictor is less than $F_{IN}$.


### Code Implementation
We will show how to implement the various methods using an online news popularity data set. The data set includes 58 predictors and 39644 rows of observations. Examples of the predictors include number of words in the title, number of words in the article, a binary value for each day of the week, and average polarity of the words used. The two non-predictive columns we removed are url and timedelta, which is the time between the article being published and being added to the dataset. The goal is to determine which of the 58 predictors are most useful in using linear regression to find the number of times an article is shared. 

The code below shows how to perform all three of the stepwise procedures. The output in R typically shows detailed steps of the different models, but only the summaries have been included here.


```{r, results='hide', cache = TRUE}
# Load the data
news = read.csv('OnlineNewsPopularity.csv') %>% select(-url, -timedelta)

# Define intercept only model
regnull <- lm(shares~1, data=news)
# Define model with all predictors
regfull <- lm(shares~., data=news)
# Perform Forward Selection, start with regnull
forward_selection = step(regnull, scope=list(lower=regnull, upper=regfull), direction="forward")
# Perform Backward Elimination, start with regfull
backward_elimination = step(regfull, scope=list(lower=regnull, upper=regfull), direction="backward")
# Perform Stepwise Regression, start with regnull
stepwise_regression = step(regnull, scope=list(lower=regnull, upper=regfull), direction="both")
```

```{r}
# Results from Forward Selection
summary(forward_selection)
# Results from Backward Elimination
summary(backward_elimination)
# Results from Stepwise Regression
summary(stepwise_regression)

```


**Results**

As seen above, the three stepwise-type procedures do not give the same results as each other. Forward selection and stepwise regression have the same output in this scenario, but it is not guaranteed the results from forward selection and stepwise regression would be equal for a different model. Backward elimination includes 2 more predictor variables than the other two methods, which results in a higher adjusted $R^2$ value. The residual standard errors are the same, and this shows how different combinations of predictors can have similar performances. It is valuable to perform all three of these processes and pick a model based on the context of the problem.

### Pros & Cons

**Pros**

1. Subset selection is easy to implement and may work with categorical and continuous predictors.

2. The coefficients assigned to the predictors selected using subset selection are easy to interpret, which is useful for inference problems.

3. The three stepwise-type procedures are able to be used when there are many predictors.


**Cons**

1. When there are a large number of predictors possible, the time to run the best subset formula can become restrictive.

2. Results of the best subset and stepwise-type procedure may vary based on the model selection parameters used. 

3. If the number of observations is small, then a small change in the data may result in a significant change to the model.

4. These methods only work for supervised learning problems.



# Penalized Regression

# Dimension Reduction

In the methods described so far, we have focused on feature selection and eliminating features that we decide are not significant enough for our model. However, in entirely dropping these features - however insignificant they may be - we completely miss out on any benefits these dropped variables may contribute. Instead, we could incorporate all variables strategically in order to extract as much information as possible using dimension reduction. Dimension reduction entails creating an $M$-dimensional subspace where $M$ combinations are constructed as a combination of $p$ predictors. The $M$ combinations of predictors are then used to fit a least squares linear regression model. In order to benefit from this approach, $M < p$ must hold. If $M = p$, then the resulting model amounts to using a least squares fit using all of the original predictors. We especially benefit from this approach when $p$ (number of predictors) is large relative to n (number of observations), as using $M < p$ can reduce the variance of the model. 

Dimension reduction methods generally follow two steps:  
1. Obtain the transformed predictors $Z_1$, $Z_2$,...$Z_M$  
2. Fit the model using these predictors

In the following sections, we will discuss two popular methods for dimension reduction: Principal Component Analysis (PCA) and Partial Least Squares (PLS).


## Principal Components Analysis (PCA)

Principal Components Analysis is a dimension reduction technique in which variables named principal components are constructed as linear combinations of our original variables. There are as many principal components created as there are original variables in our data. However, in order to attain a model with reduced dimensions, we will aim to drop a number of these principal components. To determine which principal components can be excluded from our model, we will  rank the principal components by their importance in predicting the response variable. Then, only the most important principal components are used in the linear model. 

We will likely want to use this method when we seek to reduce the number of variables, but do not know which ones. However, we will see that one drawback of this method is its interpretability, as we are no longer using our original predictors to predict the response but are instead using transformed predictors that each include all of our original predictors. 

Before we dive into the algorithm and steps behind PCA, it will be helpful to review how and why we use variance to rank principal components by importance.

### Constructing Principal Components

Principal components represent the directions of the data that explain a maximal amount of variance. In understanding this method, it’s important to recognize that variance explained is equivalent to information captured in a model. The more variance in the data that we can explain through a feature, the better.

The image below will help explain how this concept ties into principal component analysis. 

![(Source: Z, Jaadi, “A Step-by-Step Explanation of Principal Component Analysis.)](https://builtin.com/sites/default/files/inline-images/Principal%20Component%20Analysis%20second%20principal.gif)

The goal of principal component analysis is to compress as much information or variance in the first components, and thus the first principal component accounts for the largest variance in the dataset. 

In the scatterplot above, we aim to construct a principal component or line that maximizes this variance, which is when the red dots are spread out the most along the line. This line then represents more variance and the larger the variance represented by a line, the larger the dispersion of points along a line, and thus the more information the line holds.

Now that we understand how these principal components contribute to our model, let’s walk through the steps taken to construct the principal components. 

### Algorithm Behind the Method:

1. Center and standardize our original predictor variable matrix, $X$.  
    + This method is sensitive to variance in the predictor variables, so this step is necessary to ensure each variable contributes equally to the model  
2. Compute the covariance matrix by multiplying the transpose of this standardized matrix by itself.  
    + Thus, where X has been standardized: $X^TX$  
3. Compute the eigenvectors and eigenvalues of the covariance matrix, $X^TX$.  
    + Let’s pause here for a refresher on linear algebra:  
        + Eigenvectors represent directions and eigenvalues represent magnitude (or in this scenario, importance). Eigenvectors are stored in a dense matrix while eigenvalues are stored in a matrix with eigenvalues on the diagonal and zeros everywhere else. These eigenvalues on the diagonal are associated with the corresponding column in the eigenvector matrix. For example, an eigenvalue stored on the diagonal in the second column of its matrix corresponds to the second column in the eigenvector matrix.  
        + Luckily, there are functions in R that will compute these values for us, but it’s important to understand the eigenvectors and eigenvalues it outputs.  
        
![](https://media.giphy.com/media/ZThQqlxY5BXMc/source.gif)

4. Sort the eigenvalues from largest to smallest  
    + Since eigenvalues correspond to their eigenvectors, the eigenvectors are similarly sorted according to the order of their corresponding eigenvalue (put another way, the columns of the eigenvector matrix are reordered according to the reordering of the eigenvalue matrix).  
5. Multiply this sorted eigenvector matrix by the standardized version of X from step 1.  
    + As a result, we now have a standardized version of X with weights determined by the eigenvectors.  
6. With this new matrix, determine how many features (principal components) to keep in the new feature matrix. This can be done a couple of ways:  
    a) Arbitrarily determine how many dimensions to keep:  
        + This is not recommended, but at times may be appropriate for your specific analysis or problem  

    b) Set a threshold for proportion of variance explained:  
        + As explained earlier, the importance of a principal component or eigenvector is tied to variance. Further, each eigenvalue is approximately the importance of its corresponding eigenvalue (as we saw when sorting our eigenvalues and then eigenvectors). Therefore, we can create a metric for measuring the importance or variance explained by each principal component or eigenvector called the proportion of variance, which is the sum of all eigenvalues kept divided by the sum of all eigenvalues.  
        + With this metric, we can then pick a threshold of proportion of variance explained and include principal components up until we reach the set threshold.
 
     c) Use a scree plot:  
        + Similar to the method above, we can use the proportion of variance to determine how many principal components to keep.     
        + We calculate the proportion of variance for each principal component, sort the principal components by proportion of variance explained (though they technically should already be sorted in order of importance), then plot the proportion of variance explained by each principal component.  
        + We should then have a line plot with an elbow that denotes the point at which there is the largest drop in proportion of variance explained. We then decide to use the principal components up until this drop. In the scree plot below, there is a considerable drop between proportion of variance explained in PC1 to PC2. We would therefore identify PC2 as the elbow and only include the first feature (PC1) and drop the rest. As you can see, a disadvantage of this method is that it is relatively subjective.

![(Source: https://datavizpyr.com/how-to-make-scree-plot-in-r-with-ggplot2/)](https://i2.wp.com/datavizpyr.com/wp-content/uploads/2020/08/Scree_plot_with_geom_line_ggplot2.png?w=600&ssl=1)

7. Use this new feature matrix with the principal components/eigenvectors we chose to keep as the new X in our linear regression model against the untransformed Y -- this type of regression using PCA is known as Principal Components Regression (PCR).  

    + Note: Each of these new variables resulting from PCA are all independent of each other, which is an important assumption that must hold for a linear model.
    
### Code Implementation

```{r, include=FALSE}
library(dplyr)
set.seed(123)
```
There are a couple of libraries you can use for PCR - one 'pls' which also can be used for PLS (covered next). We'll first show how to run PCR using this library:
```{r, message=FALSE}
library(pls)
```
Run PCR with cross-validation:
```{r}
news = read.csv('OnlineNewsPopularity.csv') %>% select(-url, -timedelta)
pcr.fit = pcr(shares~., data = news, scale=TRUE, validation ="CV")
```
In the above code, scale is set to "TRUE" in order to standardize each predictor. Validation is set to "CV" in order to compute ten-fold cross-validation error for each possible value of M (the number of principal components used). Having the cross-validation error will give us another metric to judge principal components by.

Summary:
```{r}
summary(pcr.fit)
```
From this summary, we see that the smallest RMSE at 55 components (M=55) of 11522, at which point 100% of variance is explained.

More info on the `pls` package is available [here](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf).


Next, we can use the function prcomp() within the core stats package for PCR. The difference in setting up pcr() vs. prcomp() is that prcomp() needs the data passed in with no response variable. Therefore, we create an X from our data, removing our response variable, shares.
```{r, message=FALSE}
X = news %>% select(-shares)

prcomp.fit = prcomp(X, scale = TRUE)

summary(prcomp.fit)
```
Similar to pcr(), we have a summary table with all PCs. Instead, here we have Proportion of Variance and Cumulative Proportion available to us. 

Next, visualize eigenvalues (scree plot). We will use fviz_eig located within the factoextra package. Show the percentage of variances explained by each principal component. 58 is passed in for "ncp" in order to visualize all PCs. If you would like to view less, you can change this input.
```{r, message=FALSE}
library(factoextra)
fviz_eig(prcomp.fit, ncp = 58)
```

More info on the `prcomp` is available [here](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/prcomp.html).

More info on the `factoextra` package is available [here](https://cran.r-project.org/web/packages/factoextra/factoextra.pdf).

## Partial Least Squares (PLS)

Partial least squares (PLS) is very similar to principal components regression (PCR), in that both generate a new set of features that are linear combinations of the original features. However, unlike PCR, PLS incorporates information from the response variable when creating these new features. In doing so, PLS attempts to identify directions that explain the most variance in both the features and the response, rather than just explaining the variance in the features. Because PCR only considers the variance in the features, it may not be best for prediction, particularly if there is some variance in the features unrelated to the variance in the response.

PLS can be thought of as a supervised alternative to PCR's unsupervised approach. This is not to say that PCR cannot be used for supervised learning problems (it can be used for either supervised or unsupervised problems), but instead describes the method of generating the new features. PLS, on the other hand, can only be used for supervised problems, since the response variable is used in the creation of the new features.

![](https://media.giphy.com/media/ehVD71SQYsCHWrWgvs/giphy.gif){width=50%}

### Algorithm

PLS generates new features $Z$ that are linear combinations of the original features $X$. This means that the $m$th new feature can be written as $Z_m = \sum_{j = 1}^p \phi_{jm}X_j$, where $p$ is the total number of original features.

This process for creating these new features is as follows:

1. Standardize all features.

2. Initialize $X^{(0)} = X$ and $m=1$.

3. Compute the first direction $Z_1$ by setting $\phi_{j1}$ equal to the coefficient of ordinary least squares linear regression between $Y$ and $X_j$. In doing so, the $X_j$'s most highly correlated with $Y$ receive the highest weights in $Z_1$.

4. Orthogonalize $X$ with respect to $Z_1$ by regressing each variable $X_j$ on $Z_1$ and taking the residuals. Denote these orthogonalized values $X^{(1)}$. This means that $X^{(1)}$ is essentially the information not already explained by the first direction.

5. Repeat steps 2-4 to calculate each $Z_m$ for $m = 2, ..., p$, using the orthogonalized $X^{(m-1)}$ output from the previous step instead of $X$ to generate $Z_m$. So $X^{(1)}$ is used to calculate $Z_2$, $X^{(2)}$ is used to calculate $Z_3$, and so on.

6. Use ordinary least squares to regress $Y$ on $Z_1, ..., Z_m$ for some $m \le p$. Generally use cross-validation to choose the best value of $m$.

### Code Implementation

```{r read_data, message=FALSE}
library(tidyverse)
news <- read_csv("OnlineNewsPopularity.csv")

news_cl <- select(news, -url, -timedelta)
```

To implement PLS in R, we can use the `pls` package. After loading the package, the basic syntax for fitting PLS regression is very similar to that of linear regression with the `lm` function, though in this case we will use the `plsr` function. The first argument is a formula to tell the function what the response and predictor variables are. In this case, we're using online news data with `shares` as the response and all other variables as predictors. To avoid having to type out 58 variables in the formula, we can instead use `shares ~ .` to indicate that all columns besides `shares` should be treated as predictor variables. Additionally, to standardize the predictors, we can specify `scale = TRUE` and `center = TRUE`.

```{r fit_pls, message=FALSE}
#load the pls library
library(pls)

#fit the pls regression
pls_fit <- plsr(shares ~ ., data = news_cl, scale = TRUE, center = TRUE)

summary(pls_fit)
```

The summary of the fit shows the percentage of variance explained by each additional component. In this example, we see that five components explain 24% of the variance in the data, and 10 components explain 38% of the variance in the data. 

We can also make predictions for new data using our PLS model. As with fitting the model, this process is very similar to ordinary least squares regression. We will use the `predict` function, but will need to include an additional parameter `ncomp` to specify the number of components to include.

More info on the `pls` package is available [here](https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf).

```{r pred_pls}
#predict for given number of components (3 in this case)
predict(pls_fit, ncomp = 3, newdata = news_cl[39640:39644,])
```

While the percentage of variance explained gives us some information about how many components to include, best practice is to choose this number using cross-validation. One method of cross-validation would involve a double for loop to iterate through subsets of the data and number of components, making predictions and calculating an error measure (generally root mean squared error for numeric predictor variables) for each combination, then choosing the number of components with the smallest RMSE. However, the `caret` package can simplify this process considerably using the `train` function. We need to include the same parameters as in the function call to `plsr`, along with a few additional parameters. We specify `method = "pcr"` since `train` can handle many different model types, `trControl = trainControl("cv", number = 10)` to indicate that we want 10-fold cross-validation, and `tuneLength = 10` to indicate that we want to test values from 1 to 10 for the `ncomp` parameter.

```{r pls_cv, message=FALSE}
library(caret)

#set seed for reproducibility, since CV involves random partitions
set.seed(300)
 
pls_cv <- train(shares ~ ., data = news_cl, scale = TRUE, center = TRUE, 
               method = "pcr", trControl = trainControl("cv", number = 10), 
               tuneLength = 10)

plot(pls_cv)

pls_cv$bestTune
```

From cross-validation, we see that two components is the best choice, and that including more than that may lead to overfitting.

More info on the `caret` package can be found [here](http://topepo.github.io/caret/index.html).

### Pros & Cons

PLS can perform well for prediction when there are many features, even when multicollinearity is present, violating the assumptions for ordinary least squares (OLS). Multicollinearity occurs when some predictor variables are highly correlated with some combination of other predictor variables, and occurs increasingly often as the number of predictor variables grows. Therefore PLS can be useful for prediction with high-dimensional data (when the number of predictors $p$ is large relative to the number of observations $n$). However, PLS is less interpretable than OLS in understanding the underlying relationship between features and response, since it involves the creation of new features.

PLS generally has lower bias but higher variance than PCR.

PLS can have minor instability in its estimates because it tends to shrink low-variance directions but sometimes inflates high-variance directions. Ridge regression shrinks all directions, but especially low-variance directions, while PCR discards low-variance directions.

PLS, PCR, and ridge regression typically perform very similarly, but for minimizing prediction error, ridge regression is generally preferred because it shrinks smoothly as opposed to in discrete steps.

## Conclusion

In summary, it is important to consider the number of predictors being used to fit your model in OLS. Commonly, not all predictors are necessary and instead can lead to overfitting. We have outlined a few methods for either removing or transforming these predictors and unfortunately, one method is not always going to be the best method - it depends on the context of your data and the problem. Ridge does tend to most frequently outperform the others, but it's important to use discretion and due diligence to test or consider a couple methods, and then perhaps compare the resulting models using MSE. 

We hope you've enjoyed our tutorial!

![](https://media.giphy.com/media/uWlpPGquhGZNFzY90z/giphy.gif)


